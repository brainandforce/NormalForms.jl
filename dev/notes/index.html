<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Package notes and FAQ · NormalForms.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://brainandforce.github.io/NormalForms.jl/notes/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NormalForms.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Package notes and FAQ</a><ul class="internal"><li><a class="tocitem" href="#Return-type-of-Transpose-and-Adjoint-matrices"><span>Return type of <code>Transpose</code> and <code>Adjoint</code> matrices</span></a></li><li><a class="tocitem" href="#Inequivalence-of-transposition-order-with-Smith-normal-form-calculations"><span>Inequivalence of transposition order with Smith normal form calculations</span></a></li><li><a class="tocitem" href="#Return-type-of-Diagonal-matrices"><span>Return type of <code>Diagonal</code> matrices</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/public/">Public</a></li><li><a class="tocitem" href="../api/internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Package notes and FAQ</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Package notes and FAQ</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brainandforce/NormalForms.jl/blob/main/docs/src/notes.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Package-notes-and-FAQ"><a class="docs-heading-anchor" href="#Package-notes-and-FAQ">Package notes and FAQ</a><a id="Package-notes-and-FAQ-1"></a><a class="docs-heading-anchor-permalink" href="#Package-notes-and-FAQ" title="Permalink"></a></h1><p>Some of the content here may seem obvious, but these are pitfalls that were discovered during package development that led to some design choices and other unusual findings that are rationalized or explained here.</p><h2 id="Return-type-of-Transpose-and-Adjoint-matrices"><a class="docs-heading-anchor" href="#Return-type-of-Transpose-and-Adjoint-matrices">Return type of <code>Transpose</code> and <code>Adjoint</code> matrices</a><a id="Return-type-of-Transpose-and-Adjoint-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Return-type-of-Transpose-and-Adjoint-matrices" title="Permalink"></a></h2><p>When a Smith or Hermite normal form calculation is performed on a <code>Transpose</code> or <code>Adjoint</code>, the unimodular factors are of the same type. The <code>transpose()</code> and <code>adjoint()</code> functions can be applied to a factorization to obtain a transposed representation.</p><h2 id="Inequivalence-of-transposition-order-with-Smith-normal-form-calculations"><a class="docs-heading-anchor" href="#Inequivalence-of-transposition-order-with-Smith-normal-form-calculations">Inequivalence of transposition order with Smith normal form calculations</a><a id="Inequivalence-of-transposition-order-with-Smith-normal-form-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Inequivalence-of-transposition-order-with-Smith-normal-form-calculations" title="Permalink"></a></h2><p>In general, <code>hnfc(M&#39;) == hnfr(M)&#39;</code>, and <code>hnfr(M&#39;) == hnfc(M)&#39;</code>. It is also true that  <code>snf(M).S == snf(M&#39;)&#39;.S == snf(M)&#39;.S</code>. However, <code>snf(M&#39;).U</code> is not guaranteed to be equal to <code>snf(M)&#39;.U</code>, and the same goes for <code>snf(M&#39;).V</code> and <code>snf(M)&#39;.V</code>! This is because the choice of unimodular factors is not unique with respect to the rounding mode of the Euclidean division steps.</p><p>What is guaranteed is that <code>snf(M).S == snf(M&#39;).S == snf(M)&#39;.S</code>, <code>snf(M)&#39;.S == snf(M&#39;).S == snf(M&#39;).V * M * snf(M&#39;).U == snf(M)&#39;.V * M&#39; * snf(M)&#39;.U</code>. In the future, we may modify the algorithm to guarantee <code>snf(M&#39;) == snf(M)&#39;</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We&#39;ve generally used the adjoint (prime) operator, but everything stated for adjoints here also holds for transposes.</p></div></div><h2 id="Return-type-of-Diagonal-matrices"><a class="docs-heading-anchor" href="#Return-type-of-Diagonal-matrices">Return type of <code>Diagonal</code> matrices</a><a id="Return-type-of-Diagonal-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Return-type-of-Diagonal-matrices" title="Permalink"></a></h2><p>You might notice that if you perform a Smith normal form calculation on a <code>Diagonal</code> matrix, the result is a <code>Smith{T, Matrix{T}}</code>, instead of <code>Smith{T, Diagonal{T, Vector{T}}}</code>. However, this is not the case for Hermite normal form calculations, which will return an <code>AbstractHermite{T, Diagonal{T, Vector{T}}}</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; M = Diagonal([7,12,6])
3×3 Diagonal{Int64, Vector{Int64}}:
 7   ⋅  ⋅
 ⋅  12  ⋅
 ⋅   ⋅  6

julia&gt; snf(M)
3×3 Smith{Int64, Matrix{Int64}}:
Smith normal form:
3×3 Matrix{Int64}:
 1  0   0
 0  6   0
 0  0  84
Left unimodular factor:
3×3 Matrix{Int64}:
  1   3  0
 12  35  1
 12  35  0
Right unimodular factor:
3×3 Matrix{Int64}:
 -5  0   36
  1  0   -7
  0  1  -14

julia&gt; hnfc(M)
3×3 ColumnHermite{Int64, Diagonal{Int64, Vector{Int64}}}:
Hermite normal form:
3×3 Diagonal{Int64, Vector{Int64}}:
 7   ⋅  ⋅
 ⋅  12  ⋅
 ⋅   ⋅  6
Unimodular factor:
3×3 Diagonal{Int64, Vector{Int64}}:
 1  ⋅  ⋅
 ⋅  1  ⋅
 ⋅  ⋅  1

julia&gt; hnfr(M)
3×3 RowHermite{Int64, Diagonal{Int64, Vector{Int64}}}:
Hermite normal form:
3×3 Diagonal{Int64, Vector{Int64}}:
 7   ⋅  ⋅
 ⋅  12  ⋅
 ⋅   ⋅  6
Unimodular factor:
3×3 Diagonal{Int64, Vector{Int64}}:
 1  ⋅  ⋅
 ⋅  1  ⋅
 ⋅  ⋅  1
</code></pre><p>A diagonal matrix automatically satisfies all of the requirements for being in Hermite normal form, so the unimodular factor is just an identity matrix, which can be stored in a <code>Diagonal</code> representation. However, <em>it does not automatically satisfy the divisibility requirements for a  matrix in Smith normal form.</em> Therefore, the matrix is converted to a dense matrix so that the unimodular factors, which themselves must be stored as dense matrices, can be permuted in the usual way.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/public/">Public »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 15 January 2025 23:04">Wednesday 15 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
